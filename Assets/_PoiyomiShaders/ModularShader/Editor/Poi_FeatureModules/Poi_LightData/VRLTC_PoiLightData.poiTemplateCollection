#T#PoiLightingDataBasePassProps

[HideInInspector] m_start_PoiLightData ("Light Data--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/light-data},hover:Documentation}}", Float) = 0
// Lighting Data
[sRGBWarning]_LightingAOMaps ("AO Maps (expand)--{reference_properties:[_LightingAOMapsPan, _LightingAOMapsUV,_LightDataAOStrengthR,_LightDataAOStrengthG,_LightDataAOStrengthB,_LightDataAOStrengthA]}", 2D) = "white" { }
[HideInInspector][Vector2]_LightingAOMapsPan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)] _LightingAOMapsUV ("UV", Int) = 0
[HideInInspector]_LightDataAOStrengthR ("R Strength", Range(0, 1)) = 1
[HideInInspector]_LightDataAOStrengthG ("G Strength", Range(0, 1)) = 0
[HideInInspector]_LightDataAOStrengthB ("B Strength", Range(0, 1)) = 0
[HideInInspector]_LightDataAOStrengthA ("A Strength", Range(0, 1)) = 0
[sRGBWarning]_LightingDetailShadowMaps ("Detail Shadows (expand)--{reference_properties:[_LightingDetailShadowMapsPan, _LightingDetailShadowMapsUV,_LightingDetailShadowStrengthR,_LightingDetailShadowStrengthG,_LightingDetailShadowStrengthB,_LightingDetailShadowStrengthA,_LightingAddDetailShadowStrengthR,_LightingAddDetailShadowStrengthG,_LightingAddDetailShadowStrengthB,_LightingAddDetailShadowStrengthA]}", 2D) = "white" { }
[HideInInspector][Vector2]_LightingDetailShadowMapsPan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)] _LightingDetailShadowMapsUV ("UV", Int) = 0
[HideInInspector]_LightingDetailShadowStrengthR ("R Strength", Range(0, 1)) = 1
[HideInInspector]_LightingDetailShadowStrengthG ("G Strength", Range(0, 1)) = 0
[HideInInspector]_LightingDetailShadowStrengthB ("B Strength", Range(0, 1)) = 0
[HideInInspector]_LightingDetailShadowStrengthA ("A Strength", Range(0, 1)) = 0
[HideInInspector]_LightingAddDetailShadowStrengthR ("Additive R Strength", Range(0, 1)) = 1
[HideInInspector]_LightingAddDetailShadowStrengthG ("Additive G Strength", Range(0, 1)) = 0
[HideInInspector]_LightingAddDetailShadowStrengthB ("Additive B Strength", Range(0, 1)) = 0
[HideInInspector]_LightingAddDetailShadowStrengthA ("Additive A Strength", Range(0, 1)) = 0
[sRGBWarning]_LightingShadowMasks ("Shadow Masks (expand)--{reference_properties:[_LightingShadowMasksPan, _LightingShadowMasksUV,_LightingShadowMaskStrengthR,_LightingShadowMaskStrengthG,_LightingShadowMaskStrengthB,_LightingShadowMaskStrengthA]}", 2D) = "white" { }
[HideInInspector][Vector2]_LightingShadowMasksPan ("Panning", Vector) = (0, 0, 0, 0)
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7)] _LightingShadowMasksUV ("UV", Int) = 0
[HideInInspector]_LightingShadowMaskStrengthR ("R Strength", Range(0, 1)) = 1
[HideInInspector]_LightingShadowMaskStrengthG ("G Strength", Range(0, 1)) = 0
[HideInInspector]_LightingShadowMaskStrengthB ("B Strength", Range(0, 1)) = 0
[HideInInspector]_LightingShadowMaskStrengthA ("A Strength", Range(0, 1)) = 0
// Base Pass
[Space(15)]
[ThryHeaderLabel(Base Pass Lighting, 13)]
[Space(4)]
[Enum(Poi Custom, 0, Standard, 1, UTS2, 2, OpenLit (lil toon), 3)] _LightingColorMode ("Light Color Mode", Int) = 0
[Enum(Poi Custom, 0, Normalized NDotL, 1, Saturated NDotL, 2)] _LightingMapMode ("Light Map Mode", Int) = 0
[Enum(Poi Custom, 0, Forced Local Direction, 1, Forced World Direction, 2, UTS2, 3, OpenLit (lil toon), 4)] _LightingDirectionMode ("Light Direction Mode", Int) = 0
[Vector3]_LightngForcedDirection ("Forced Direction--{condition_showS:(_LightingDirectionMode==1 || _LightingDirectionMode==2)}", Vector) = (0, 0, 0)
[ToggleUI]_LightingForceColorEnabled ("Force Light Color", Float) = 0
_LightingForcedColor ("Forced Color--{condition_showS:(_LightingForceColorEnabled==1), reference_property:_LightingForcedColorThemeIndex}", Color) = (1, 1, 1)
[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _LightingForcedColorThemeIndex ("", Int) = 0
_Unlit_Intensity ("Unlit_Intensity--{condition_showS:(_LightingColorMode==2)}", Range(0.001, 4)) = 1
[ToggleUI]_LightingCapEnabled ("Limit Brightness", Float) = 1
_LightingCap ("Max Brightness--{condition_showS:(_LightingCapEnabled==1)}", Range(0, 10)) = 1
_LightingMinLightBrightness ("Min Brightness", Range(0, 1)) = 0
_LightingIndirectUsesNormals ("Indirect Uses Normals--{condition_showS:(_LightingColorMode==0)}", Range(0, 1)) = 0
_LightingCastedShadows ("Receive Casted Shadows", Range(0, 1)) = 0
_LightingMonochromatic ("Grayscale Lighting", Range(0, 1)) = 0
// Lighting Additive
[Space(15)]
[ThryHeaderLabel(Add Pass Lighting, 13)]
[Space(4)]
[ThryToggle(POI_LIGHT_DATA_ADDITIVE_ENABLE)]_LightingAdditiveEnable ("Enable Additive", Float) = 1
[ThryToggle(POI_LIGHT_DATA_ADDITIVE_DIRECTIONAL_ENABLE)]_DisableDirectionalInAdd ("Ignore Directional--{condition_showS:(_LightingAdditiveEnable==1)}", Float) = 1
[ToggleUI]_LightingAdditiveLimited ("Limit Brightness?--{condition_showS:(_LightingAdditiveEnable==1)}", Float) = 0
_LightingAdditiveLimit ("Max Brightness--{ condition_showS:(_LightingAdditiveLimited==1&&_LightingAdditiveEnable==1)}", Range(0, 10)) = 1
_LightingAdditiveMonochromatic ("Grayscale Lighting", Range(0, 1)) = 0
_LightingAdditivePassthrough ("Point Light Passthrough--{condition_showS:(_LightingAdditiveEnable==1)}", Range(0, 1)) = .5
// Vertex Lighting
[Space(15)]
[ThryHeaderLabel(Vertex Lighting, 13)]
[Space(4)]
[ThryToggle(POI_VERTEXLIGHT_ON)]_LightingVertexLightingEnabled ("Enabled", Float) = 1
// Lighting Data Debug
[Space(15)]
[ThryHeaderLabel(Debug Visualization, 13)]
[Space(4)]
[ThryToggle(POI_LIGHT_DATA_DEBUG)]_LightDataDebugEnabled ("Debug", Float) = 0
[ThryWideEnum(Direct Color, 0, Indirect Color, 1, Light Map, 2, Attenuation, 3, N Dot L, 4, Half Dir, 5, Direction, 6, Add Color, 7, Add Attenuation, 8, Add Shadow, 9, Add N Dot L, 10)] _LightingDebugVisualize ("Visualize--{condition_showS:(_LightDataDebugEnabled==1)}", Int) = 0

[HideInInspector] m_end_PoiLightData ("Light Data", Float) = 0


#T#PoiLightingDataKeywords
#pragma shader_feature_local POI_LIGHT_DATA_DEBUG
#pragma shader_feature_local POI_LIGHT_DATA_ADDITIVE_ENABLE
#pragma shader_feature_local POI_LIGHT_DATA_ADDITIVE_DIRECTIONAL_ENABLE
#pragma shader_feature_local POI_VERTEXLIGHT_ON

#T#PoiLightingDataVariables
#if defined(PROP_LIGHTINGAOMAPS) || !defined(OPTIMIZER_ENABLED)
	Texture2D _LightingAOMaps;
#endif
float4 _LightingAOMaps_ST;
float2 _LightingAOMapsPan;
float _LightingAOMapsUV;
float _LightDataAOStrengthR;
float _LightDataAOStrengthG;
float _LightDataAOStrengthB;
float _LightDataAOStrengthA;

#if defined(PROP_LIGHTINGDETAILSHADOWMAPS) || !defined(OPTIMIZER_ENABLED)
	Texture2D _LightingDetailShadowMaps;
#endif
float4 _LightingDetailShadowMaps_ST;
float2 _LightingDetailShadowMapsPan;
float _LightingDetailShadowMapsUV;
float _LightingDetailShadowStrengthR;
float _LightingDetailShadowStrengthG;
float _LightingDetailShadowStrengthB;
float _LightingDetailShadowStrengthA;
float _LightingAddDetailShadowStrengthR;
float _LightingAddDetailShadowStrengthG;
float _LightingAddDetailShadowStrengthB;
float _LightingAddDetailShadowStrengthA;

#if defined(PROP_LIGHTINGSHADOWMASKS) || !defined(OPTIMIZER_ENABLED)
	Texture2D _LightingShadowMasks;
#endif
float4 _LightingShadowMasks_ST;
float2 _LightingShadowMasksPan;
float _LightingShadowMasksUV;
float _LightingShadowMaskStrengthR;
float _LightingShadowMaskStrengthG;
float _LightingShadowMaskStrengthB;
float _LightingShadowMaskStrengthA;

// Lighting Data
float _Unlit_Intensity;
float _LightingColorMode;
float _LightingMapMode;
float _LightingDirectionMode;
float3 _LightngForcedDirection;
float _LightingIndirectUsesNormals;
float _LightingCapEnabled;
float _LightingCap;
float _LightingForceColorEnabled;
float3 _LightingForcedColor;
float _LightingForcedColorThemeIndex;
float _LightingCastedShadows;
float _LightingMonochromatic;
float _LightingAdditiveMonochromatic;
float _LightingMinLightBrightness;
// Additive Lighting Data
float _LightingAdditiveLimited;
float _LightingAdditiveLimit;
float _LightingAdditivePassthrough;
// Lighting Data Debug
float _LightingDebugVisualize;


#T#PoiLightingDataImplementation

poiLight.finalLightAdd = 0;
#if defined(PROP_LIGHTINGAOMAPS) || !defined(OPTIMIZER_ENABLED)
	float4 AOMaps = POI2D_SAMPLER_PAN(_LightingAOMaps, _MainTex, poiUV(poiMesh.uv[_LightingAOMapsUV], _LightingAOMaps_ST), _LightingAOMapsPan);
	poiLight.occlusion = min(min(min(lerp(1, AOMaps.r, _LightDataAOStrengthR), lerp(1, AOMaps.g, _LightDataAOStrengthG)), lerp(1, AOMaps.b, _LightDataAOStrengthB)),lerp(1, AOMaps.a, _LightDataAOStrengthA));
#else
	poiLight.occlusion = 1;
#endif
#if defined(PROP_LIGHTINGDETAILSHADOWMAPS) || !defined(OPTIMIZER_ENABLED)
	float4 DetailShadows = POI2D_SAMPLER_PAN(_LightingDetailShadowMaps, _MainTex, poiUV(poiMesh.uv[_LightingDetailShadowMapsUV], _LightingDetailShadowMaps_ST), _LightingDetailShadowMapsPan);
	#ifndef POI_PASS_ADD
		poiLight.detailShadow = lerp(1, DetailShadows.r, _LightingDetailShadowStrengthR) * lerp(1, DetailShadows.g, _LightingDetailShadowStrengthG) * lerp(1, DetailShadows.b, _LightingDetailShadowStrengthB) * lerp(1, DetailShadows.a, _LightingDetailShadowStrengthA);
	#else
		poiLight.detailShadow = lerp(1, DetailShadows.r, _LightingAddDetailShadowStrengthR) * lerp(1, DetailShadows.g, _LightingAddDetailShadowStrengthG) * lerp(1, DetailShadows.b, _LightingAddDetailShadowStrengthB) * lerp(1, DetailShadows.a, _LightingAddDetailShadowStrengthA);
	#endif
#else
	poiLight.detailShadow = 1;
#endif
#if defined(PROP_LIGHTINGSHADOWMASKS) || !defined(OPTIMIZER_ENABLED)
	float4 ShadowMasks = POI2D_SAMPLER_PAN(_LightingShadowMasks, _MainTex, poiUV(poiMesh.uv[_LightingShadowMasksUV], _LightingShadowMasks_ST), _LightingShadowMasksPan);
	poiLight.shadowMask = lerp(1, ShadowMasks.r, _LightingShadowMaskStrengthR) * lerp(1, ShadowMasks.g, _LightingShadowMaskStrengthG) * lerp(1, ShadowMasks.b, _LightingShadowMaskStrengthB) * lerp(1, ShadowMasks.a, _LightingShadowMaskStrengthA);
#else
	poiLight.shadowMask = 1;
#endif

#ifdef UNITY_PASS_FORWARDBASE

	bool lightExists = false;
	if (any(_LightColor0.rgb >= 0.002))
	{
		lightExists = true;
	}

	#if defined(VERTEXLIGHT_ON) && defined(POI_VERTEXLIGHT_ON)
		float4 toLightX = unity_4LightPosX0 - i.worldPos.x;
		float4 toLightY = unity_4LightPosY0 - i.worldPos.y;
		float4 toLightZ = unity_4LightPosZ0 - i.worldPos.z;
		float4 lengthSq = 0;
		lengthSq += toLightX * toLightX;
		lengthSq += toLightY * toLightY;
		lengthSq += toLightZ * toLightZ;
		
		float4 lightAttenSq = unity_4LightAtten0;
		float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
		float4 vLightWeight = saturate(1 - (lengthSq * lightAttenSq / 25));
		poiLight.vAttenuation = min(atten, vLightWeight * vLightWeight);
		
		poiLight.vDotNL = 0;
		poiLight.vDotNL += toLightX * poiMesh.normals[1].x;
		poiLight.vDotNL += toLightY * poiMesh.normals[1].y;
		poiLight.vDotNL += toLightZ * poiMesh.normals[1].z;
		
		float4 corr = rsqrt(lengthSq);
		poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);

		poiLight.vertexVDotNL = 0;
		poiLight.vertexVDotNL += toLightX * poiMesh.normals[0].x;
		poiLight.vertexVDotNL += toLightY * poiMesh.normals[0].y;
		poiLight.vertexVDotNL += toLightZ * poiMesh.normals[0].z;
		
		poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);

		poiLight.vAttenuationDotNL = saturate(poiLight.vAttenuation * saturate(poiLight.vDotNL));
		
		for (int index = 0; index < 4; index++)
		{
			poiLight.vPosition[index] = float3(unity_4LightPosX0[index], unity_4LightPosY0[index], unity_4LightPosZ0[index]);
			
			float3 vertexToLightSource = poiLight.vPosition[index] - poiMesh.worldPos;
			poiLight.vDirection[index] = normalize(vertexToLightSource);
			//poiLight.vAttenuationDotNL[index] = 1.0 / (1.0 + unity_4LightAtten0[index] * poiLight.vDotNL[index]);
			poiLight.vColor[index] = lerp(unity_LightColor[index].rgb, dot(unity_LightColor[index].rgb, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
			poiLight.vHalfDir[index] = Unity_SafeNormalize(poiLight.vDirection[index] + poiCam.viewDir);
			poiLight.vDotNL[index] = dot(poiMesh.normals[1], -poiLight.vDirection[index]);
			poiLight.vCorrectedDotNL[index] = .5 * (poiLight.vDotNL[index] + 1);
			poiLight.vDotLH[index] = saturate(dot(poiLight.vDirection[index], poiLight.vHalfDir[index]));
			
			poiLight.vDotNH[index] = dot(poiMesh.normals[1], poiLight.vHalfDir[index]);
			poiLight.vertexVDotNH[index] = saturate(dot(poiMesh.normals[0], poiLight.vHalfDir[index]));
		}
	#endif



	//UNITY_BRANCH
	if (_LightingColorMode == 0) // Poi Custom Light Color

	{
		float3 magic = max(BetterSH9(normalize(unity_SHAr + unity_SHAg + unity_SHAb)), 0);
		float3 normalLight = _LightColor0.rgb + BetterSH9(float4(0, 0, 0, 1));
		
		float magiLumi = calculateluminance(magic);
		float normaLumi = calculateluminance(normalLight);
		float maginormalumi = magiLumi + normaLumi;
		
		float magiratio = magiLumi / maginormalumi;
		float normaRatio = normaLumi / maginormalumi;
		
		float target = calculateluminance(magic * magiratio + normalLight * normaRatio);
		float3 properLightColor = magic + normalLight;
		float properLuminance = calculateluminance(magic + normalLight);
		poiLight.directColor = properLightColor * max(0.0001, (target / properLuminance));

		poiLight.indirectColor = BetterSH9(float4(lerp(0, poiMesh.normals[1], _LightingIndirectUsesNormals), 1));
	}

	//UNITY_BRANCH
	if (_LightingColorMode == 1) // More standard approach to light color

	{
		float3 indirectColor = BetterSH9(float4(poiMesh.normals[1], 1));
		if (lightExists)
		{
			poiLight.directColor = _LightColor0.rgb;
			poiLight.indirectColor = indirectColor;
		}
		else
		{
			poiLight.directColor = indirectColor * 0.6;
			poiLight.indirectColor = indirectColor * 0.5;
		}
	}

	if (_LightingColorMode == 2) // UTS style

	{
		poiLight.indirectColor = saturate(max(half3(0.05, 0.05, 0.05) * _Unlit_Intensity, max(ShadeSH9(half4(0.0, 0.0, 0.0, 1.0)), ShadeSH9(half4(0.0, -1.0, 0.0, 1.0)).rgb) * _Unlit_Intensity));
		poiLight.directColor = max(poiLight.indirectColor, _LightColor0.rgb);
	}

	if (_LightingColorMode == 3) // OpenLit

	{
		float3 lightDirectionForSH9 = OpenLitLightingDirection();
		OpenLitShadeSH9ToonDouble(lightDirectionForSH9, poiLight.directColor, poiLight.indirectColor);
		poiLight.directColor += _LightColor0.rgb;
		// OpenLit does a few other things by default like clamp direct colour
		// see https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl#L174
		// Should we add (if) statements to override Poi versions of these things?
		// Or should we add new properties with same names with the same functions?

	}

	float lightMapMode = _LightingMapMode;
	//UNITY_BRANCH
	if (_LightingDirectionMode == 0)
	{
		poiLight.direction = _WorldSpaceLightPos0.xyz + unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz;
	}
	if (_LightingDirectionMode == 1 || _LightingDirectionMode == 2)
	{
		//UNITY_BRANCH
		if (_LightingDirectionMode == 1)
		{
			poiLight.direction = mul(unity_ObjectToWorld, _LightngForcedDirection).xyz;;
		}
		//UNITY_BRANCH
		if (_LightingDirectionMode == 2)
		{
			poiLight.direction = _LightngForcedDirection;
		}
		if (lightMapMode == 0)
		{
			lightMapMode == 1;
		}
	}

	if (_LightingDirectionMode == 3) // UTS

	{
		float3 defaultLightDirection = normalize(UNITY_MATRIX_V[2].xyz + UNITY_MATRIX_V[1].xyz);
		float3 lightDirection = normalize(lerp(defaultLightDirection, _WorldSpaceLightPos0.xyz, any(_WorldSpaceLightPos0.xyz)));
		poiLight.direction = lightDirection;
	}
	if (_LightingDirectionMode == 4) // OpenLit

	{
		poiLight.direction = OpenLitLightingDirection(); // float4 customDir = 0; // Do we want to give users to alter this (OpenLit always does!)?

	}

	if (!any(poiLight.direction))
	{
		poiLight.direction = float3(.4, 1, .4);
	}

	poiLight.direction = normalize(poiLight.direction);
	poiLight.attenuationStrength = _LightingCastedShadows;
	poiLight.attenuation = 1;
	if (!all(_LightColor0.rgb == 0.0))
	{
		UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos)
		poiLight.attenuation *= attenuation;
	}

	if (!any(poiLight.directColor) && !any(poiLight.indirectColor) && lightMapMode == 0)
	{
		lightMapMode = 1;
		if (_LightingDirectionMode == 0)
		{
			poiLight.direction = normalize(float3(.4, 1, .4));
		}
	}

	poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
	poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
	poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
	poiLight.nDotLSaturated = saturate(poiLight.nDotL);
	poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
	poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
	poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
	poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
	poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
	poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
	poiLight.lDotH = max(0.00001, dot(poiLight.direction, poiLight.halfDir));
	

	// Poi special light map
	if (lightMapMode == 0)
	{
		float3 ShadeSH9Plus = GetSHLength();
		float3 ShadeSH9Minus = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;

		float3 greyScaleVector = float3(.33333, .33333, .33333);
		float bw_lightColor = dot(poiLight.directColor, greyScaleVector);
		float bw_directLighting = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor * lerp(1, poiLight.attenuation, poiLight.attenuationStrength)) + dot(ShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
		float bw_bottomIndirectLighting = dot(ShadeSH9Minus, greyScaleVector);
		float bw_topIndirectLighting = dot(ShadeSH9Plus, greyScaleVector);
		float lightDifference = ((bw_topIndirectLighting + bw_lightColor) - bw_bottomIndirectLighting);
		poiLight.lightMap = smoothstep(0, lightDifference, bw_directLighting - bw_bottomIndirectLighting) * poiLight.detailShadow;
	}
	// Normalized nDotL
	if (lightMapMode == 1)
	{
		poiLight.lightMap = poiLight.nDotLNormalized * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
	}
	// Saturated nDotL
	if (lightMapMode == 2)
	{
		poiLight.lightMap = poiLight.nDotLSaturated * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
	}

	poiLight.directColor = max(poiLight.directColor, 0.0001);
	poiLight.indirectColor = max(poiLight.indirectColor, 0.0001);
	if (_LightingColorMode == 3)
	{
		poiLight.directColor = max(poiLight.directColor, _LightingMinLightBrightness);
		poiLight.indirectColor = max(poiLight.indirectColor, _LightingMinLightBrightness);
	}
	else
	{
		poiLight.directColor = max(poiLight.directColor, poiLight.directColor / max(0.0001, (calculateluminance(poiLight.directColor) / _LightingMinLightBrightness)));
		poiLight.indirectColor = max(poiLight.indirectColor, poiLight.indirectColor / max(0.0001, (calculateluminance(poiLight.indirectColor) / _LightingMinLightBrightness)));
	}

	poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
	poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
	//UNITY_BRANCH
	if (_LightingCapEnabled)
	{
		poiLight.directColor = min(poiLight.directColor, _LightingCap);
		poiLight.indirectColor = min(poiLight.indirectColor, _LightingCap);
	}



	//UNITY_BRANCH
	if (_LightingForceColorEnabled)
	{
		poiLight.directColor = poiThemeColor(poiMods, _LightingForcedColor, _LightingForcedColorThemeIndex);
	}

	#K#BASE_LIGHTDATA_MOD
	
#endif

#ifdef POI_PASS_ADD
	#ifndef POI_LIGHT_DATA_ADDITIVE_ENABLE
		return float4(mainTexture.rgb * .0001, 1);
	#endif

	#if defined(POI_LIGHT_DATA_ADDITIVE_DIRECTIONAL_ENABLE) && defined(DIRECTIONAL)
		return float4(mainTexture.rgb * .0001, 1);
	#endif

	#if defined(POINT) || defined(SPOT)
		poiLight.direction = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);
		

		#ifdef POINT
			poiLight.additiveShadow = UNITY_SHADOW_ATTENUATION(i, poiMesh.worldPos);
			unityShadowCoord3 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1)).xyz;
			poiLight.attenuation = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).r;
		#endif

		#ifdef SPOT
			poiLight.additiveShadow = UNITY_SHADOW_ATTENUATION(i, poiMesh.worldPos);
			unityShadowCoord4 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1));
			poiLight.attenuation = (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz);
		#endif
	#else
		poiLight.direction = _WorldSpaceLightPos0.xyz;
		UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos)
		poiLight.additiveShadow == 0;
		poiLight.attenuation = attenuation;
	#endif
	poiLight.directColor = _LightingAdditiveLimited ? min(_LightingAdditiveLimit, _LightColor0.rgb) : _LightColor0.rgb;

	#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
		poiLight.indirectColor = 0;
	#else
		poiLight.indirectColor = lerp(0, poiLight.directColor, _LightingAdditivePassthrough);
	#endif

	
	
	poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
	poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);

	poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
	poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
	poiLight.nDotLSaturated = saturate(poiLight.nDotL);
	poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
	poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
	poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
	poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
	poiLight.lDotH = dot(poiLight.direction, poiLight.halfDir);
	poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
	poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
	poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
	poiLight.lightMap = 1;
#endif

#ifdef POI_LIGHT_DATA_DEBUG
	
	#ifdef UNITY_PASS_FORWARDBASE
		//UNITY_BRANCH
		if (_LightingDebugVisualize <= 6)
		{
			switch(_LightingDebugVisualize)
			{
				case 0: // Direct Light Color
				return float4(poiLight.directColor + mainTexture.rgb * .0001, 1);
				break;
				case 1: // Indirect Light Color
				return float4(poiLight.indirectColor + mainTexture.rgb * .0001, 1);
				break;
				case 2: // Light Map
				return float4(poiLight.lightMap + mainTexture.rgb * .0001, 1);
				break;
				case 3: // Attenuation
				return float4(poiLight.attenuation + mainTexture.rgb * .0001, 1);
				break;
				case 4: // N Dot L
				return float4(poiLight.nDotLNormalized, poiLight.nDotLNormalized, poiLight.nDotLNormalized, 1) + mainTexture * .0001;
				break;
				case 5:
					return float4(poiLight.halfDir, 1) + mainTexture * .0001;
				break;
				case 6:
					return float4(poiLight.direction, 1) + mainTexture * .0001;
				break;
			}
		}
		else
		{
			return POI_SAFE_RGB1;
		}
	#endif
	#ifdef POI_PASS_ADD
		//UNITY_BRANCH
		if (_LightingDebugVisualize < 6)
		{
			return POI_SAFE_RGB1;
		}
		else
		{
			switch(_LightingDebugVisualize)
			{
				case 7:
					return float4(poiLight.directColor * poiLight.attenuation + mainTexture.rgb * .0001, 1);
				break;
				case 8:
					return float4(poiLight.attenuation + mainTexture.rgb * .0001, 1);
				break;
				case 9:
					return float4(poiLight.additiveShadow + mainTexture.rgb * .0001, 1);
				break;
				case 10:
					return float4(poiLight.nDotLNormalized + mainTexture.rgb * .0001, 1);
				break;
				case 11:
					return float4(poiLight.halfDir, 1) + mainTexture * .0001;
				break;
			}
		}
	#endif
#endif